/* \author Geoffrey Biggs */


//Boost libraries
#include <boost/thread/thread.hpp>

// PCL libraries
#include <pcl/common/common_headers.h>
#include <pcl/common/distances.h>
#include <pcl/features/normal_3d.h>
#include <pcl/io/pcd_io.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/console/parse.h>
#include <pcl/point_types.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <pcl/ModelCoefficients.h>
#include <pcl/io/pcd_io.h>
#include <pcl/point_types.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/passthrough.h>
#include <pcl/features/normal_3d.h>
#include <pcl/sample_consensus/method_types.h>
#include <pcl/sample_consensus/model_types.h>
#include <pcl/segmentation/sac_segmentation.h>

// cpp libraries
#include <chrono>
#include <ctime>
#include <tuple>        
#include <iostream>
#include <string>
#include <fstream>

#include <planeSegmentation.h>


class Tree
{
public:
    pcl::ModelCoefficients::Ptr cylinderCoef;
    pcl::PointIndices::Ptr cylinderPointcloud;
    pcl::PointCloud<pcl::PointXYZRGB> treePoints;

    int numPointcloud = 0;
    double radius =0.0;
    double perimeter = 0.0;
    double height = 0.0;

};

void
printUsage (const char* progName)
{
  std::cout << "\n\nUsage: "<<progName<<" [options]\n\n"
            << "Options:\n"
            << "-------------------------------------------\n"
            << "-h           this help\n"
            << "-s           Simple visualisation example\n"
            << "-r           RGB colour visualisation example\n"
            << "-c           Custom colour visualisation example\n"
            << "-n           Normals visualisation example\n"
            << "-a           Shapes visualisation example\n"
            << "-v           Viewports example\n"
            << "-i           Interaction Customization example\n"
            << "\n\n";
}



Tree getCylinderCoeff(pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloud,
                      pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr keyframe,
                      pcl::PointCloud<pcl::Normal>::Ptr &normals,
                      double dPointDistance,
                      int KeypointLocation,
                      pcl::ModelCoefficients::Ptr &PlaneCoefficients) {

 	pcl::PointXYZRGB tempKeyPoint = keyframe->points[KeypointLocation];
	double tkpx = tempKeyPoint.x;
	double tkpy = tempKeyPoint.y;
	double tkpz = tempKeyPoint.z;
	
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr point_cloud_ptr (new pcl::PointCloud<pcl::PointXYZRGB>);
	point_cloud_ptr->points.push_back(tempKeyPoint);
	for(size_t j = 0; j < cloud->points.size(); j++)
	{
		pcl::PointXYZRGB point = cloud->points[j];
	
		double tmpx = point.x;
		double tmpy = point.y;
		double tmpz = point.z;
		double dist = sqrt(pow(tkpx-tmpx,2.0)+pow(tkpy-tmpy,2.0)+pow(tkpz-tmpz,2.0));
	
		if(dist < dPointDistance)
		{
			float tfrgb = point.rgb;
			uint32_t temprgb = *reinterpret_cast<uint32_t*>(&tfrgb);
			if(temprgb == 16777215) 
				continue;	//It's a keyframe point, skip it for now

	  		point_cloud_ptr->points.push_back (point);
		}
	}


    cout << "check point 1 " << endl;


	point_cloud_ptr->width = (int) point_cloud_ptr->points.size ();
	point_cloud_ptr->height = 1;


	pcl::NormalEstimation<pcl::PointXYZRGB, pcl::Normal> ne;
	ne.setInputCloud (point_cloud_ptr);
	pcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZRGB> ());
	ne.setSearchMethod (tree);
	pcl::PointCloud<pcl::Normal>::Ptr cloud_normals2 (new pcl::PointCloud<pcl::Normal>);
//  ne.setKSearch(50);
	ne.setRadiusSearch (1.0);
//	ne.compute (*cloud_normals2);
    cout << "check point 2 " << endl;

	// Create the segmentation object for cylinder segmentation and set all the parameters
    const float ax = PlaneCoefficients->values[0];
    const float ay = PlaneCoefficients->values[1];
    const float az = PlaneCoefficients->values[2];
    const Eigen::Vector3f cylinderAxis(ax,ay,az);
    const double epsAngle = 10.0/180.0 * M_PI;


	pcl::SACSegmentationFromNormals<pcl::PointXYZRGB, pcl::Normal> seg;
	pcl::PointIndices::Ptr inliers_cylinder (new pcl::PointIndices);
	pcl::ModelCoefficients::Ptr coefficients_cylinder (new pcl::ModelCoefficients);


	cout << "axis is : " << cylinderAxis << endl;

	seg.setOptimizeCoefficients (false);
	seg.setModelType (pcl::SACMODEL_CYLINDER);
    seg.setAxis(cylinderAxis);
    seg.setEpsAngle(epsAngle);
	seg.setMethodType (pcl::SAC_RANSAC);
	seg.setNormalDistanceWeight (0.0);
	seg.setMaxIterations (50000);
	seg.setDistanceThreshold (0.2);
	seg.setRadiusLimits (0.02, 0.1);
	seg.setInputCloud (point_cloud_ptr);
//	seg.setInputNormals (cloud_normals2);
    seg.setInputNormals (normals);



//    cout << "check point 3 " << endl;

    // Obtain the cylinder inliers and coefficients
	seg.segment (*inliers_cylinder, *coefficients_cylinder);
    cout << "check point 4 " << endl;
    if(inliers_cylinder->indices.size() > 0){

        cout << "Size of inliers is : " << inliers_cylinder->indices.size() << endl;
    }


    Tree currentTree;

    //No cylinder found
    if(coefficients_cylinder->values.size() == 0 or inliers_cylinder->indices.size() < 30 )
    {
        coefficients_cylinder->header.frame_id = "NULL";
        currentTree.cylinderCoef = coefficients_cylinder;
        currentTree.cylinderPointcloud = inliers_cylinder;
        return currentTree ;
    }
    cout << "Cylinder coefficient is : " << *coefficients_cylinder << endl;


	double tmpx = coefficients_cylinder->values[0];
	double tmpy = coefficients_cylinder->values[1];
	double tmpz = coefficients_cylinder->values[2];
	double dist = sqrt(pow(tkpx-tmpx,2.0)+pow(tkpy-tmpy,2.0)+pow(tkpz-tmpz,2.0));
	if(dist > dPointDistance)
	{
        coefficients_cylinder->header.frame_id = "NULL";
        currentTree.cylinderCoef = coefficients_cylinder;
        currentTree.cylinderPointcloud = inliers_cylinder;
        return currentTree ;
	}



    pcl::ExtractIndices<pcl::PointXYZRGB> extract (true);
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud_p (new pcl::PointCloud<pcl::PointXYZRGB>);
    extract.setInputCloud (point_cloud_ptr);
    extract.setIndices (inliers_cylinder);
    extract.setNegative (false);
    cout << "check point 5 " << endl;
    extract.filter(*cloud_p);
    cout << "Size of cloud is : " << cloud->points.size() << endl;
    cout << "Size of cloud_p is : " << cloud_p->points.size() << endl;

    currentTree.cylinderCoef = coefficients_cylinder;
    currentTree.cylinderPointcloud = inliers_cylinder;
    currentTree.numPointcloud = (int) inliers_cylinder->indices.size();
    currentTree.radius = coefficients_cylinder->values[6];
    currentTree.perimeter = currentTree.radius * 2 * M_PI;

    /*
    for(int i=0; i< inliers_cylinder->indices.size(); i++){
        cout << "the 3D point is : ("<< point_cloud_ptr->points[i].x << " , "
             << point_cloud_ptr->points[i].y << " , " << point_cloud_ptr->points[i].z << ")" <<endl;
        currentTree.treePoints.push_back(point_cloud_ptr->points[i]) ;
    }
*/
    return currentTree;

}

boost::shared_ptr<pcl::visualization::PCLVisualizer> cylinderVis (pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloud, std::vector<pcl::ModelCoefficients::Ptr> vCylinders)
//pcl::ModelCoefficients::Ptr cylinderPtr)
{
  // --------------------------------------------
  // -----Open 3D viewer and add point cloud-----
  // --------------------------------------------
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
  viewer->setBackgroundColor (0, 0, 0);
  pcl::visualization::PointCloudColorHandlerRGBField<pcl::PointXYZRGB> rgb(cloud);
  viewer->addPointCloud<pcl::PointXYZRGB> (cloud, rgb, "sample cloud");
  viewer->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud");
  viewer->addCoordinateSystem (1.0);
  viewer->initCameraParameters ();

  //------------------------------------
  //-----Add shapes at cloud points-----
  //------------------------------------
  
  for(size_t i = 0; i < vCylinders.size(); i++)
  {
	pcl::ModelCoefficients::Ptr coeffPtr = vCylinders[i];
	pcl::ModelCoefficients coeff = *coeffPtr;
	cout << "Cylinder coefficients: " << coeff << endl;
	if(coeff.values[6] < 0)
		continue;	//Invalid cylinder
	std::stringstream ss;
	ss.str() = "";
	ss << "cylinder : " << i;
	std::string sID = ss.str();
	viewer->addCylinder (coeff, sID);
  }

  return (viewer);
}


boost::shared_ptr<pcl::visualization::PCLVisualizer> simpleVis (pcl::PointCloud<pcl::PointXYZ>::ConstPtr cloud)
{
  // --------------------------------------------
  // -----Open 3D viewer and add point cloud-----
  // --------------------------------------------
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
  viewer->setBackgroundColor (0, 0, 0);
  viewer->addPointCloud<pcl::PointXYZ> (cloud, "sample cloud");
  viewer->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "sample cloud");
  viewer->addCoordinateSystem (1.0);
  viewer->initCameraParameters ();
  return (viewer);
}


boost::shared_ptr<pcl::visualization::PCLVisualizer> rgbVis (pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloud)
{
  // --------------------------------------------
  // -----Open 3D viewer and add point cloud-----
  // --------------------------------------------
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
  viewer->setBackgroundColor (0, 0, 0);
  pcl::visualization::PointCloudColorHandlerRGBField<pcl::PointXYZRGB> rgb(cloud);
  viewer->addPointCloud<pcl::PointXYZRGB> (cloud, rgb, "sample cloud");
  viewer->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 2, "sample cloud");
  viewer->addCoordinateSystem (1.0);
  viewer->initCameraParameters ();
  return (viewer);
}


boost::shared_ptr<pcl::visualization::PCLVisualizer> customColourVis (pcl::PointCloud<pcl::PointXYZ>::ConstPtr cloud)
{
  // --------------------------------------------
  // -----Open 3D viewer and add point cloud-----
  // --------------------------------------------
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
  viewer->setBackgroundColor (0, 0, 0);
  pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZ> single_color(cloud, 0, 255, 0);
  viewer->addPointCloud<pcl::PointXYZ> (cloud, single_color, "sample cloud");
  viewer->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud");
  viewer->addCoordinateSystem (1.0);
  viewer->initCameraParameters ();
  return (viewer);
}


boost::shared_ptr<pcl::visualization::PCLVisualizer> normalsVis (
    pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloud, pcl::PointCloud<pcl::Normal>::ConstPtr normals)
{
  // --------------------------------------------------------
  // -----Open 3D viewer and add point cloud and normals-----
  // --------------------------------------------------------
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
  viewer->setBackgroundColor (0, 0, 0);
  pcl::visualization::PointCloudColorHandlerRGBField<pcl::PointXYZRGB> rgb(cloud);
  viewer->addPointCloud<pcl::PointXYZRGB> (cloud, rgb, "sample cloud");
  viewer->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 2, "sample cloud");
  viewer->addPointCloudNormals<pcl::PointXYZRGB, pcl::Normal> (cloud, normals, 10, 0.05, "normals");
  viewer->addCoordinateSystem (1.0);
  viewer->initCameraParameters ();
  
  pcl::Normal randNormal = normals->points[70];
  pcl::PointXYZRGB randPoint = cloud->points[70];
  cout << "Point : " << randPoint.x << ", " << randPoint.y << ", " << randPoint.z << endl;
  cout << "Normal point: " << randNormal.normal_x << ", " << randNormal.normal_y << ", " << randNormal.normal_z << endl;
  
  cout << "eq: " << (randPoint.x * randNormal.normal_x) + (randPoint.y * randNormal.normal_y) + (randPoint.z * randNormal.normal_z) << endl;
  
  pcl::ModelCoefficients coeffs;
  coeffs.values.push_back (randPoint.x);
  coeffs.values.push_back (randPoint.y);
  coeffs.values.push_back (randPoint.z);
  coeffs.values.push_back (randNormal.normal_x);
  coeffs.values.push_back (randNormal.normal_y);
  coeffs.values.push_back (randNormal.normal_z);
  coeffs.values.push_back (0.01);
  viewer->addCylinder (coeffs);
  
  return (viewer);
}


boost::shared_ptr<pcl::visualization::PCLVisualizer> shapesVis (pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloud)
{
  // --------------------------------------------
  // -----Open 3D viewer and add point cloud-----
  // --------------------------------------------
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
  viewer->setBackgroundColor (0, 0, 0);
  pcl::visualization::PointCloudColorHandlerRGBField<pcl::PointXYZRGB> rgb(cloud);
  viewer->addPointCloud<pcl::PointXYZRGB> (cloud, rgb, "sample cloud");
  viewer->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud");
  viewer->addCoordinateSystem (1.0);
  viewer->initCameraParameters ();

  //------------------------------------
  //-----Add shapes at cloud points-----
  //------------------------------------
  viewer->addLine<pcl::PointXYZRGB> (cloud->points[0],
                                     cloud->points[cloud->size() - 1], "line");
  viewer->addSphere (cloud->points[0], 0.2, 0.5, 0.5, 0.0, "sphere");

  //---------------------------------------
  //-----Add shapes at other locations-----
  //---------------------------------------
  pcl::ModelCoefficients coeffs;
  coeffs.values.push_back (0.0);
  coeffs.values.push_back (0.0);
  coeffs.values.push_back (1.0);
  coeffs.values.push_back (0.0);
  viewer->addPlane (coeffs, "plane");
  coeffs.values.clear ();
  coeffs.values.push_back (0.3);
  coeffs.values.push_back (0.3);
  coeffs.values.push_back (0.0);
  coeffs.values.push_back (0.0);
  coeffs.values.push_back (1.0);
  coeffs.values.push_back (0.0);
  coeffs.values.push_back (5.0);
  viewer->addCone (coeffs, "cone");

  return (viewer);
}


boost::shared_ptr<pcl::visualization::PCLVisualizer> viewportsVis (
    pcl::PointCloud<pcl::PointXYZRGB>::ConstPtr cloud, pcl::PointCloud<pcl::Normal>::ConstPtr normals1, pcl::PointCloud<pcl::Normal>::ConstPtr normals2)
{
  // --------------------------------------------------------
  // -----Open 3D viewer and add point cloud and normals-----
  // --------------------------------------------------------
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
  viewer->initCameraParameters ();

  int v1(0);
  viewer->createViewPort(0.0, 0.0, 0.5, 1.0, v1);
  viewer->setBackgroundColor (0, 0, 0, v1);
  viewer->addText("Radius: 0.01", 10, 10, "v1 text", v1);
  pcl::visualization::PointCloudColorHandlerRGBField<pcl::PointXYZRGB> rgb(cloud);
  viewer->addPointCloud<pcl::PointXYZRGB> (cloud, rgb, "sample cloud1", v1);

  int v2(0);
  viewer->createViewPort(0.5, 0.0, 1.0, 1.0, v2);
  viewer->setBackgroundColor (0.3, 0.3, 0.3, v2);
  viewer->addText("Radius: 0.1", 10, 10, "v2 text", v2);
  pcl::visualization::PointCloudColorHandlerCustom<pcl::PointXYZRGB> single_color(cloud, 0, 255, 0);
  viewer->addPointCloud<pcl::PointXYZRGB> (cloud, single_color, "sample cloud2", v2);

  viewer->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 1, "sample cloud1");
  viewer->setPointCloudRenderingProperties (pcl::visualization::PCL_VISUALIZER_POINT_SIZE, 3, "sample cloud2");
  viewer->addCoordinateSystem (1.0);

  viewer->addPointCloudNormals<pcl::PointXYZRGB, pcl::Normal> (cloud, normals1, 10, 0.05, "normals1", v1);
  viewer->addPointCloudNormals<pcl::PointXYZRGB, pcl::Normal> (cloud, normals2, 10, 0.05, "normals2", v2);

  return (viewer);
}


unsigned int text_id = 0;
void keyboardEventOccurred (const pcl::visualization::KeyboardEvent &event,
                            void* viewer_void)
{
  pcl::visualization::PCLVisualizer *viewer = static_cast<pcl::visualization::PCLVisualizer *> (viewer_void);
  if (event.getKeySym () == "r" && event.keyDown ())
  {
    std::cout << "r was pressed => removing all text" << std::endl;

    char str[512];
    for (unsigned int i = 0; i < text_id; ++i)
    {
      sprintf (str, "text#%03d", i);
      viewer->removeShape (str);
    }
    text_id = 0;
  }
}

void mouseEventOccurred (const pcl::visualization::MouseEvent &event,
                         void* viewer_void)
{
  pcl::visualization::PCLVisualizer *viewer = static_cast<pcl::visualization::PCLVisualizer *> (viewer_void);
  if (event.getButton () == pcl::visualization::MouseEvent::LeftButton &&
      event.getType () == pcl::visualization::MouseEvent::MouseButtonRelease)
  {
    std::cout << "Left mouse button released at position (" << event.getX () << ", " << event.getY () << ")" << std::endl;

    char str[512];
    sprintf (str, "text#%03d", text_id ++);
    viewer->addText ("clicked here", event.getX (), event.getY (), str);
  }
}

boost::shared_ptr<pcl::visualization::PCLVisualizer> interactionCustomizationVis ()
{
  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
  viewer->setBackgroundColor (0, 0, 0);
  viewer->addCoordinateSystem (1.0);

  viewer->registerKeyboardCallback (keyboardEventOccurred, (void*)viewer.get ());
  viewer->registerMouseCallback (mouseEventOccurred, (void*)viewer.get ());

  return (viewer);
}


int planeSegmentation(pcl::PointCloud<pcl::PointXYZRGB>::Ptr &point_cloud_ptr,
                      pcl::ModelCoefficients::Ptr &PlaneCoefficients,
                      pcl::PointIndices::Ptr &PlaneInliers,
                      pcl::PointCloud<pcl::PointXYZRGB>::Ptr &planePointcloud,
                      pcl::PointCloud<pcl::PointXYZRGB>::Ptr &noPlanePointcloud) {
    // (input, output, output, output, output)
    // Create the segmentation object
    pcl::SACSegmentation<pcl::PointXYZRGB> PlaneSeg;
    // Optional
    PlaneSeg.setOptimizeCoefficients (false);
    // Mandatory
    PlaneSeg.setModelType (pcl::SACMODEL_PLANE);
    PlaneSeg.setMethodType (pcl::SAC_RANSAC);
    PlaneSeg.setDistanceThreshold (0.4);

    PlaneSeg.setInputCloud (point_cloud_ptr);
    PlaneSeg.segment (*PlaneInliers, *PlaneCoefficients);

    if (PlaneInliers->indices.size () == 0)
    {
        PCL_ERROR ("Could not estimate a planar model from the given dataset.");

        return -1;
    }

    std::cerr << "Plane model coefficients: " << PlaneCoefficients->values[0] << " "
              << PlaneCoefficients->values[1] << " "
              << PlaneCoefficients->values[2] << " "
              << PlaneCoefficients->values[3] << std::endl;

    cout << "Size of all point cloud is : " << point_cloud_ptr->points.size() << endl;
    std::cerr << "Model PlaneInliers: " << PlaneInliers->indices.size () << std::endl;

    std::sort(PlaneInliers->indices.begin(), PlaneInliers->indices.end());

    int planeIndexCounter = 0;

    for(int i=0 ; i< point_cloud_ptr->points.size();i++) {
        if(i >= PlaneInliers->indices[planeIndexCounter]) {
            planeIndexCounter++;
            planePointcloud->points.push_back(point_cloud_ptr->points[i]);
            continue;
        }
        noPlanePointcloud->points.push_back(point_cloud_ptr->points[i]);
    }

    return 1;
}

// --------------
// -----Main-----
// --------------
int
main (int argc, char** argv)
{


  // --------------------------------------
  // -----Parse Command Line Arguments-----
  // --------------------------------------
  std::string sInput = "";
  std::string sInputKeyframe = "";
  double dPointDistance = 1.0;
  if (pcl::console::find_argument (argc, argv, "-h") >= 0)
  {
    printUsage (argv[0]);
    return 0;
  }
  bool simple(false), rgb(false), custom_c(false), normals(false),
    shapes(false), viewports(false), interaction_customization(false);
  if (pcl::console::find_argument (argc, argv, "-s") >= 0)
  {
    simple = true;
    std::cout << "Simple visualisation example\n";
  }
  else if (pcl::console::find_argument (argc, argv, "-c") >= 0)
  {
    custom_c = true;
    std::cout << "Custom colour visualisation example\n";
  }
  else if (pcl::console::find_argument (argc, argv, "-r") >= 0)
  {
    rgb = true;
    std::cout << "RGB colour visualisation example\n";
  }
  else if (pcl::console::find_argument (argc, argv, "-n") >= 0)
  {
    normals = true;
    std::cout << "Normals visualisation example\n";
  }
  else if (pcl::console::find_argument (argc, argv, "-a") >= 0)
  {
    shapes = true;
    std::cout << "Shapes visualisation example\n";
  }
  else if (pcl::console::find_argument (argc, argv, "-v") >= 0)
  {
    viewports = true;
    std::cout << "Viewports example\n";
  }
  else if (pcl::console::find_argument (argc, argv, "-i") >= 0)
  {
    interaction_customization = true;
    std::cout << "Interaction Customization example\n";
  }
  else
  {
    printUsage (argv[0]);
    return 0;
  }

  // ------------------------------------
  // -----Create example point cloud-----
  // ------------------------------------
  pcl::PointCloud<pcl::PointXYZ>::Ptr basic_cloud_ptr (new pcl::PointCloud<pcl::PointXYZ>);
  pcl::PointCloud<pcl::PointXYZRGB>::Ptr point_cloud_ptr (new pcl::PointCloud<pcl::PointXYZRGB>);
  pcl::PointCloud<pcl::PointXYZRGB>::Ptr keypoint_ptr (new pcl::PointCloud<pcl::PointXYZRGB>);
  
  pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZRGB>);
  //std::vector<int> vkpCounter;
  double tkpx = 0, tkpy = 0, tkpz = 0;
  
  
  if(argc == 5)
  {
  	sInput = std::string(argv[2]);
  	sInputKeyframe = std::string(argv[3]);
  	dPointDistance = std::stod(argv[4]);
  	
  	//Input cloud will have pcd format and color in float bits (reinterpret cast from uint32_t)
  	pcl::io::loadPCDFile (sInput, *point_cloud_ptr);
  	pcl::io::loadPCDFile (sInputKeyframe, *keypoint_ptr);
  	/*
  	//int tKPLoc = 15;
  	pcl::PointXYZRGB tempKeyPoint = keypoint_ptr->points[tKPLoc];
  	tkpx = tempKeyPoint.x;
  	tkpy = tempKeyPoint.y;
  	tkpz = tempKeyPoint.z;
  	//int kpcounter = 0;
  	
  	point_cloud_ptr->points.push_back(tempKeyPoint);
  	for(size_t j = 0; j < cloud->points.size(); j++)
  	{
  		pcl::PointXYZRGB point = cloud->points[j];
  		
  		double tmpx = point.x;
  		double tmpy = point.y;
  		double tmpz = point.z;
  		double dist = sqrt(pow(tkpx-tmpx,2.0)+pow(tkpy-tmpy,2.0)+pow(tkpz-tmpz,2.0));
  		
  		if(dist < dPointDistance)
  		{
  			float tfrgb = point.rgb;
  			uint32_t temprgb = *reinterpret_cast<uint32_t*>(&tfrgb);
  			if(temprgb == 16777215) 
  				continue;	//It's a keyframe point, skip it for now
  				//vkpCounter.push_back(kpcounter);
	  		point_cloud_ptr->points.push_back (point);
  		}
  	}
  	cout << "conversion done.. " << endl;
  	//cout << "KF total :" << vkpCounter.size() << endl;
  	*/
  	
  	/*
  	cout << "KF at: " << endl;
  	for(size_t k = 0; k < vkpCounter.size(); k++)
  	{
  		int location = vkpCounter[k];
  		cout << point_cloud_ptr->points[location].x << ", " << point_cloud_ptr->points[location].y << ", " << point_cloud_ptr->points[location].z << ", Color: " << point_cloud_ptr->points[location].rgb << endl;
  	}
  	cout << "-------------------------" << endl;
  	*/
  }
  else {
      return -1;
  }

  basic_cloud_ptr->width = (int) basic_cloud_ptr->points.size ();
  basic_cloud_ptr->height = 1;
  point_cloud_ptr->width = (int) point_cloud_ptr->points.size ();
  point_cloud_ptr->height = 1;
  keypoint_ptr->width = (int) keypoint_ptr->points.size ();
  keypoint_ptr->height = 1;
  	
  pcl::PCDWriter writer;

  pcl::ModelCoefficients::Ptr PlaneCoefficients (new pcl::ModelCoefficients);
  pcl::PointIndices::Ptr PlaneInliers (new pcl::PointIndices);
  pcl::PointCloud<pcl::PointXYZRGB>::Ptr planePointcloud (new pcl::PointCloud<pcl::PointXYZRGB>);
  pcl::PointCloud<pcl::PointXYZRGB>::Ptr noPlanePointcloud (new pcl::PointCloud<pcl::PointXYZRGB>);

  int isPlane = planeSegmentation(point_cloud_ptr,PlaneCoefficients,PlaneInliers, planePointcloud, noPlanePointcloud);

  if(isPlane == -1)
      return -1;

  cout << "Total points without plane is : " << noPlanePointcloud->points.size() << endl;
  cout << "Total points considered as a plane : " << planePointcloud->points.size() << endl;
  cout << "Comparison between all points and plane + without plane : " << point_cloud_ptr->points.size()
       << " | " << noPlanePointcloud->points.size() + planePointcloud->points.size() << endl;



  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewerPlane (new pcl::visualization::PCLVisualizer ("Plane viewer"));
  viewerPlane->setBackgroundColor (0, 0, 0);
  viewerPlane->addPointCloud<pcl::PointXYZRGB> (planePointcloud, "plane cloud");
  viewerPlane->addCoordinateSystem (1.0);
  viewerPlane->initCameraParameters ();
  viewerPlane->addPlane(*PlaneCoefficients, "First plane");
  viewerPlane->setWindowName("Window name");

  viewerPlane->addArrow(keypoint_ptr->back(),keypoint_ptr->front(),0,255,0,false,"my arrow");

  while (!viewerPlane->wasStopped ()) {
      viewerPlane->spinOnce (100);
      boost::this_thread::sleep (boost::posix_time::microseconds (100000));
  }

  boost::shared_ptr<pcl::visualization::PCLVisualizer> viewerNoPlane (new pcl::visualization::PCLVisualizer ("Plane viewer"));
  viewerNoPlane->setBackgroundColor (0, 0, 0);
  viewerNoPlane->addPointCloud<pcl::PointXYZRGB> (noPlanePointcloud, "no plane cloud");
  viewerNoPlane->addCoordinateSystem (1.0);
  viewerNoPlane->initCameraParameters ();
  viewerNoPlane->addPlane(*PlaneCoefficients, "Viewing no plane");
  viewerNoPlane->setWindowName("No plane");


  while (!viewerNoPlane->wasStopped ()) {
      viewerNoPlane->spinOnce (100);
      boost::this_thread::sleep (boost::posix_time::microseconds (100000));
  }
    

    /*
    pcl::ExtractIndices<pcl::PointXYZRGB> extract (true);
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloudNoPlane (new pcl::PointCloud<pcl::PointXYZRGB>);

    extract.setInputCloud (point_cloud_ptr);
    extract.setIndices (PlaneInliers);
    extract.setNegative (false);
    extract.filter(*cloudNoPlane);
*/


  // ----------------------------------------------------------------
  // -----Calculate surface normals with a search radius of 0.05-----
  // ----------------------------------------------------------------
  pcl::NormalEstimation<pcl::PointXYZRGB, pcl::Normal> ne;
  ne.setInputCloud (noPlanePointcloud);
  //ne.setInputCloud (point_cloud_ptr);
  pcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZRGB> ());
  ne.setSearchMethod (tree);
  pcl::PointCloud<pcl::Normal>::Ptr cloud_normals1 (new pcl::PointCloud<pcl::Normal>);
  ne.setRadiusSearch (0.05);
  ne.compute (*cloud_normals1);


  // ---------------------------------------------------------------
  // -----Calculate surface normals with a search radius of 0.1-----
  // ---------------------------------------------------------------
  pcl::PointCloud<pcl::Normal>::Ptr cloud_normals2 (new pcl::PointCloud<pcl::Normal>);
  ne.setRadiusSearch (1.2);
  ne.compute (*cloud_normals2);

    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewerNormals (new pcl::visualization::PCLVisualizer ("Plane viewer"));
    viewerNormals->setBackgroundColor (0, 0, 0);
    viewerNormals->addPointCloud<pcl::PointXYZRGB> (noPlanePointcloud, "no plane cloud");
    viewerNormals->addCoordinateSystem (1.0);
    viewerNormals->initCameraParameters ();
    viewerNormals->addPlane(*PlaneCoefficients, "Viewing no plane");
    viewerNormals->setWindowName("Show normals with no plane");
    viewerNormals->addPointCloudNormals<pcl::PointXYZRGB, pcl::Normal>(noPlanePointcloud, cloud_normals2,10,0.05, "normals");

    while (!viewerNormals->wasStopped ())
    {
        viewerNormals->spinOnce (100);
        boost::this_thread::sleep (boost::posix_time::microseconds (100000));
    }



  /*
  pcl::PointCloud<pcl::PointXYZRGB>::Ptr filter_cloud_ptr (new pcl::PointCloud<pcl::PointXYZRGB>);
  pcl::PointCloud<pcl::Normal>::Ptr filter_cloud_normals (new pcl::PointCloud<pcl::Normal>);
  
  std::vector<double> vDistance;
  double dTotalDist = 0;
  for(size_t j = 0; j < cloud_normals2->points.size(); j++)
  {
  	pcl::PointXYZRGB tpoint = point_cloud_ptr->points[j];
  	pcl::Normal tkpNorm = cloud_normals2->points[j];
  	
  	float rgbVal = tpoint.rgb;
  	uint32_t trgbVal = *reinterpret_cast<uint32_t*>(&rgbVal);
  	if(trgbVal == 16777215)	//White point (is keyframe)
  	{
  		continue;
  	}
  	
  	for(size_t k = 0; k < vkpCounter.size(); k++)
  	{
  		int location = vkpCounter[k];
  		pcl::PointXYZRGB tkp = point_cloud_ptr->points[location];
  		//Eigen::Vector4f evPoint = tpoint.getVector4fMap();
  		
  		const Eigen::Vector4f evPoint(tpoint.x, tpoint.y, tpoint.z, 0.0);
  		const Eigen::Vector4f evNorm(tkpNorm.normal_x, tkpNorm.normal_y, tkpNorm.normal_z, 0.0);
  		const Eigen::Vector4f evkp(tkp.x, tkp.y, tkp.z, 0.0);
  		//const Eigen::Vector4f test(1.2,2.2,3.1,0.0);
  		//const double distt = 3.2;
  		//Eigen::Vector4f evkp = tkp.getVector4fMap();
  		
  		//sqrPointToLineDistance(point_cloud_ptr->points[location].getVector4fMap(), point_cloud_ptr->points[location].getVector4fMap(),point_cloud_ptr->points[location].getVector4fMap());
  		//sqrPointToLineDistance(evkp, evPoint, evNorm, 1.0);
  		//sqrPointToLineDistance(test,test,test,distt);
  		double sqrDist = (evNorm.cross3 (evPoint - evkp)).squaredNorm () / evNorm.squaredNorm ();
  		//Change dist here to adjust range from keypoints
  		if(sqrDist < 1e-4)
  		{
  			filter_cloud_ptr->points.push_back(tpoint);
  			filter_cloud_normals->points.push_back(tkpNorm);
  			
	  		double dist = sqrt(pow(tpoint.x-tkp.x,2.0)+pow(tpoint.y-tkp.y,2.0)+pow(tpoint.z-tkp.z,2.0));
	  		//cout << "KP " << k << " " << tkp.x << " " << tkp.y << " " << tkp.z << " point " << tpoint.x << " " << tpoint.y << " " << tpoint.z << " dist " << dist << endl;
	  		vDistance.push_back(dist);
	  		dTotalDist += dist;
  		}
  	}
  }
  filter_cloud_ptr->width = (int) filter_cloud_ptr->points.size ();
  filter_cloud_ptr->height = 1;
  
  // Scale the whole map based on height of cam
  double dMeanDist = dTotalDist / vDistance.size();
  double dScale = 1.76 / dMeanDist;
  
  cout << "Mean dist: " << dMeanDist << endl;
  cout << "Scale: " << dScale << endl;
  
  cout << "Scaling map..." << endl;
  
  pcl::PointCloud<pcl::PointXYZRGB>::Ptr scaled_cloud_ptr (new pcl::PointCloud<pcl::PointXYZRGB>);
  pcl::PointCloud<pcl::PointXYZRGB>::Ptr scaled_keypoint_ptr (new pcl::PointCloud<pcl::PointXYZRGB>);
  for(size_t j = 0; j < cloud->points.size(); j++)
  {
  	pcl::PointXYZRGB tpoint = cloud->points[j];
  	tpoint.x *= dScale;
	tpoint.y *= dScale;
	tpoint.z *= dScale;
	
	//Convert color to float
	uint32_t temprgb = (uint32_t) tpoint.rgb;
	float tfrgb = *reinterpret_cast<float*>(&temprgb);
	tpoint.rgb = tfrgb;
	scaled_cloud_ptr->points.push_back(tpoint);
  }
  
  double dTravelledDistScaled = 0;
  for(size_t j = 0; j < keypoint_ptr->points.size(); j++)
  {
  	pcl::PointXYZRGB tpoint = keypoint_ptr->points[j];
  	tpoint.x *= dScale;
	tpoint.y *= dScale;
	tpoint.z *= dScale;
	
	//Convert color to float
	uint32_t temprgb = (uint32_t) tpoint.rgb;
	float tfrgb = *reinterpret_cast<float*>(&temprgb);
	tpoint.rgb = tfrgb;
	scaled_keypoint_ptr->points.push_back(tpoint);
	
	if(j>0)
	{
		double dTempDist = sqrt(pow(scaled_keypoint_ptr->points[j].x-scaled_keypoint_ptr->points[j-1].x,2.0)+pow(scaled_keypoint_ptr->points[j].y-scaled_keypoint_ptr->points[j-1].y,2.0)+pow(scaled_keypoint_ptr->points[j].z-scaled_keypoint_ptr->points[j-1].z,2.0));
		dTravelledDistScaled += dTempDist;
	}
  }
  
  cout << "Distance travelled = " << dTravelledDistScaled << endl;
  cout << "Scaling done" << endl;
  scaled_cloud_ptr->width = (int) scaled_cloud_ptr->points.size ();
  scaled_cloud_ptr->height = 1;
  scaled_keypoint_ptr->width = (int) scaled_keypoint_ptr->points.size ();
  scaled_keypoint_ptr->height = 1;
  
  cout << "Saving scaled point cloud files..." << endl;
  writer.write ("scaled_point_cloud.pcd", *scaled_cloud_ptr, false);
  writer.write ("scaled_keyframe.pcd", *scaled_keypoint_ptr, false);
  cout << "Saved scaled point clouds" << endl;	
  */


    int treeCount = 0, treeDiscard = 0;
    std::vector< Tree > allTrees ;

    for(size_t k = 0; k < keypoint_ptr->size(); k++) {
      cout << "Loop number : " << k << endl;

      Tree currentTree;

   currentTree = getCylinderCoeff(point_cloud_ptr, keypoint_ptr, cloud_normals1, dPointDistance, k, PlaneCoefficients);

      allTrees.push_back(currentTree);

  }

    for(int i=0; i< allTrees.size(); i++) {
        if(allTrees[i].numPointcloud < 30)
            treeDiscard++;
        else {

            treeCount++;
        }

    }

    cout << "size of noPlanePointcloud is : " << noPlanePointcloud->size() << endl;

    cout << "Prepare to show the point cloud " << endl;
    cout << "Total possible trees " << allTrees.size() << endl;
    cout << "Total number of trees discarded : " << treeDiscard << endl;
    cout << "Total number of trees found : " << treeCount << endl;
#if 0
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr refinedCylinder (new pcl::PointCloud<pcl::PointXYZRGB>);

    for(int i=10; i< 16; i++) {
        for(int j=0; j< allTrees[i].treePoints.size(); j++) {
            refinedCylinder->points.push_back(allTrees[i].treePoints[j]);
        }
    }

    cout << "refinedCylinder has " << refinedCylinder->size() << " points." <<endl;


    pcl::NormalEstimation<pcl::PointXYZRGB, pcl::Normal> ne1;
    ne1.setInputCloud (refinedCylinder);
    pcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree1 (new pcl::search::KdTree<pcl::PointXYZRGB> ());
    ne1.setSearchMethod (tree1);
    pcl::PointCloud<pcl::Normal>::Ptr cloud_normals21 (new pcl::PointCloud<pcl::Normal>);
    ne1.setKSearch(50);
    ne1.compute (*cloud_normals21);

    // Create the segmentation object for cylinder segmentation and set all the parameters
    pcl::SACSegmentationFromNormals<pcl::PointXYZRGB, pcl::Normal> seg1;
    pcl::PointIndices::Ptr inliers_cylinder1 (new pcl::PointIndices);
    pcl::ModelCoefficients::Ptr coefficients_cylinder1 (new pcl::ModelCoefficients);

    seg1.setOptimizeCoefficients (false);
    seg1.setModelType (pcl::SACMODEL_CYLINDER);
    seg1.setMethodType (pcl::SAC_RANSAC);
    seg1.setNormalDistanceWeight(0.1);
    seg1.setMaxIterations (50000);
    seg1.setDistanceThreshold (0.2);
    seg1.setRadiusLimits (0.01, 0.1);
    seg1.setInputCloud (refinedCylinder);
    seg1.setInputNormals (cloud_normals21);

    // Obtain the cylinder inliers and coefficients
    seg1.segment (*inliers_cylinder1, *coefficients_cylinder1);

    if(inliers_cylinder1->indices.size() != 0){
        cout << "inliers size is : " << inliers_cylinder1->indices.size() <<endl;
        cout << "radius is : " << coefficients_cylinder1->values[6] << endl;

    }
    else
        cout << "inliers = 0" <<endl;


    pcl::PointCloud<pcl::PointXYZRGB>::Ptr refinedCylinder2 (new pcl::PointCloud<pcl::PointXYZRGB>);
    for(int i=0;i < inliers_cylinder1->indices.size();i++){
        refinedCylinder2->points.push_back(refinedCylinder->points[inliers_cylinder1->indices[i]]);
    }


    pcl::ModelCoefficients::Ptr PlaneCoefficients2 (new pcl::ModelCoefficients);
    pcl::PointIndices::Ptr PlaneInliers2 (new pcl::PointIndices);
    // Create the segmentation object
    pcl::SACSegmentation<pcl::PointXYZRGB> PlaneSeg2;
    // Optional
    PlaneSeg2.setOptimizeCoefficients (true);
    // Mandatory
    PlaneSeg2.setModelType (pcl::SACMODEL_PLANE);
    PlaneSeg2.setMethodType (pcl::SAC_RANSAC);
    PlaneSeg2.setDistanceThreshold (0.01);

    PlaneSeg2.setInputCloud (refinedCylinder);
    PlaneSeg2.segment (*PlaneInliers2, *PlaneCoefficients2);

    if (PlaneInliers2->indices.size () == 0)
    {
        PCL_ERROR ("Could not estimate a planar model for the given dataset.");

        return -1;
    }

    std::cerr << "Plane model coefficients: " << PlaneCoefficients2->values[0] << " "
              << PlaneCoefficients2->values[1] << " "
              << PlaneCoefficients2->values[2] << " "
              << PlaneCoefficients2->values[3] << std::endl;

    std::cerr << "Model PlaneInliers: " << PlaneInliers2->indices.size () << std::endl;

    pcl::PointCloud<pcl::PointXYZRGB>::Ptr refinedPlane (new pcl::PointCloud<pcl::PointXYZRGB>);


    for(int i=0;i< PlaneInliers2->indices.size();i++) {
        refinedPlane->points.push_back(refinedCylinder->points[PlaneInliers2->indices[i]]);
    }

    pcl::PointCloud<pcl::PointXYZRGB>::Ptr refinedCylinder3 (new pcl::PointCloud<pcl::PointXYZRGB>);

    for(int i=0; i< refinedCylinder->points.size();i++) {
        if(i == PlaneInliers2->indices[0]) {
            PlaneInliers2->indices.erase(PlaneInliers2->indices.begin());
            continue;
        }
        refinedCylinder3->points.push_back(refinedCylinder->points[i]);
    }


    pcl::NormalEstimation<pcl::PointXYZRGB, pcl::Normal> ne2;
    ne2.setInputCloud (refinedCylinder3);
    pcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree2 (new pcl::search::KdTree<pcl::PointXYZRGB> ());
    ne2.setSearchMethod (tree2);
    pcl::PointCloud<pcl::Normal>::Ptr cloud_normals22 (new pcl::PointCloud<pcl::Normal>);
    ne2.setKSearch(50);
    ne2.compute (*cloud_normals22);

    // Create the segmentation object for cylinder segmentation and set all the parameters
    pcl::SACSegmentationFromNormals<pcl::PointXYZRGB, pcl::Normal> seg2;
    pcl::PointIndices::Ptr inliers_cylinder2 (new pcl::PointIndices);
    pcl::ModelCoefficients::Ptr coefficients_cylinder2 (new pcl::ModelCoefficients);

    seg2.setOptimizeCoefficients (false);
    seg2.setModelType (pcl::SACMODEL_CYLINDER);
    seg2.setMethodType (pcl::SAC_RANSAC);
    seg2.setNormalDistanceWeight(0.1);
    seg2.setMaxIterations (50000);
    seg2.setDistanceThreshold (0.2);
    seg2.setRadiusLimits (0.01, 0.2);
    seg2.setInputCloud (refinedCylinder3);
    seg2.setInputNormals (cloud_normals22);

    // Obtain the cylinder inliers and coefficients
    seg2.segment (*inliers_cylinder2, *coefficients_cylinder2);


    if(inliers_cylinder2->indices.size() != 0){
        cout << "inliers2 size is : " << inliers_cylinder2->indices.size() <<endl;
        cout << "radius2 is : " << coefficients_cylinder2->values[6] << endl;

    }
    else
        cout << "inliers2 = 0" <<endl;

#endif



    auto t = std::time(nullptr);
    auto tm = *std::localtime(&t);
    std::ostringstream oss;
    oss << std::put_time(&tm, "%d-%m-%Y %H-%M-%S");
    auto currentTime = oss.str();

    ofstream treeWriter;
    treeWriter.open("tree_cloud_size"+ currentTime +".csv",ios::app);
    treeWriter << "keyframe, number of point cloud, radius (m), perimeter (m), height (m) " << endl;

    for(int i =0; i < allTrees.size(); i++) {
        treeWriter << i << "," << allTrees[i].numPointcloud << "," << allTrees[i].radius
                   << "," << allTrees[i].perimeter << "," << allTrees[i].height << endl;
    }

    treeWriter.close();

  /*
  // Create the segmentation object for cylinder segmentation and set all the parameters
  pcl::SACSegmentationFromNormals<pcl::PointXYZRGB, pcl::Normal> seg; 
  pcl::PointIndices::Ptr inliers_cylinder (new pcl::PointIndices);
  pcl::ModelCoefficients::Ptr coefficients_cylinder (new pcl::ModelCoefficients);
  
  seg.setOptimizeCoefficients (true);
  seg.setModelType (pcl::SACMODEL_CYLINDER);
  seg.setMethodType (pcl::SAC_RANSAC);
  //seg.setNormalDistanceWeight (0.1);
  seg.setMaxIterations (50000);
  seg.setDistanceThreshold (0.2);
  seg.setRadiusLimits (0, 0.15);
  seg.setInputCloud (point_cloud_ptr);
  seg.setInputNormals (cloud_normals2);

  // Obtain the cylinder inliers and coefficients
  seg.segment (*inliers_cylinder, *coefficients_cylinder);
  //cout << "Cylinder coefficients: " << *coefficients_cylinder << endl;
  // Draw the cylinder inliers
  */

    cout << "Starting visualization..." << endl;

    cout << "The first keyframe is : " << "( " << keypoint_ptr->points[0].x << " , " << keypoint_ptr->points[0].y << " , " << keypoint_ptr->points[0].z << " ) " << endl;

    int totalpoints = keypoint_ptr->size();

    cout << "The last keyframe is : " << "( " << keypoint_ptr->points[totalpoints-1].x << " , " << keypoint_ptr->points[totalpoints-1].y << " , " << keypoint_ptr->points[totalpoints-1].z << " ) " << endl;

    cout << "Total distance travelled : " << sqrt(pow(keypoint_ptr->points[totalpoints-1].x - keypoint_ptr->points[0].x,2) + pow(keypoint_ptr->points[totalpoints-1].y - keypoint_ptr->points[0].y,2)
                                          + pow(keypoint_ptr->points[totalpoints-1].z - keypoint_ptr->points[0].z,2)) << endl;

    cout << "Point size : " << keypoint_ptr->points.size() << endl;
    for(int i =0; i< keypoint_ptr->points.size();i++) {

        cout << "Coordinate of the keyframe number " << i << " is : (" << keypoint_ptr->points[i].x << " , " << keypoint_ptr->points[i].y << " , " << keypoint_ptr->points[i].z << ")" << endl;


        if(keypoint_ptr->points.size() >  i+5)
            i += 5;
        else
            break;
    }


    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer;

    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer2;

  if (simple)
  {
    viewer = simpleVis(basic_cloud_ptr);
  }
  else if (rgb)
  {
//    viewer = rgbVis(point_cloud_ptr);
  viewer = rgbVis(noPlanePointcloud);
//      viewer2 = rgbVis(point_cloud_ptr);
  }
  else if (custom_c)
  {
    viewer = customColourVis(basic_cloud_ptr);
  }
  else if (normals)
  {
  	viewer = normalsVis(point_cloud_ptr, cloud_normals2);
  }
  else if (shapes)
  {
  	//viewer = cylinderVis(point_cloud_ptr, vCylinders);
    //viewer = shapesVis(point_cloud_ptr);
  }
  else if (viewports)
  {
    viewer = viewportsVis(point_cloud_ptr, cloud_normals1, cloud_normals2);
  }
  else if (interaction_customization)
  {
    viewer = interactionCustomizationVis();
  }

    for(int i =0 ; i < allTrees.size(); i++)
    {

        if(allTrees[i].numPointcloud < 30)
            continue;

        viewer->addCylinder(*allTrees[i].cylinderCoef, "cylinder" + std::to_string(i));
    }


    //--------------------
  // -----Main loop-----
  //--------------------
  viewer->setWindowName("Main view");

  viewer->addArrow(keypoint_ptr->back(),keypoint_ptr->front(),0,255,0,false,"my arrow");


    //test adding sphere
//    viewer->addSphere(keypoint_ptr->points[0], 0.5, "first keyframe");
//    viewer->addSphere(keypoint_ptr->points[totalpoints-1], 1.0, "last keyframe");
  while (!viewer->wasStopped ())
  {
    viewer->spinOnce (100);
    boost::this_thread::sleep (boost::posix_time::microseconds (100000));
  }

/*
  viewer2->setWindowName("Cylinder view");

    while (!viewer2->wasStopped ())
    {
        viewer2->spinOnce (100);
        boost::this_thread::sleep (boost::posix_time::microseconds (100000));
    }
*/

/*
    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer2 (new pcl::visualization::PCLVisualizer ("3D Viewer1"));
    viewer2->setBackgroundColor (0, 0, 0);
    viewer2->addPointCloud<pcl::PointXYZRGB> (refinedCylinder, "sample cloud1");
    viewer2->addCoordinateSystem (1.0);
    viewer2->initCameraParameters ();
    viewer2->addPlane(*PlaneCoefficients, "planeX");
    viewer2->addCylinder(*coefficients_cylinder1, "cylinderX");

    while (!viewer2->wasStopped ())
    {
        viewer2->spinOnce (100);
        boost::this_thread::sleep (boost::posix_time::microseconds (100000));
    }

    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer3 (new pcl::visualization::PCLVisualizer ("3D Viewer2"));
    viewer3->setBackgroundColor (0, 0, 0);
    viewer3->addPointCloud<pcl::PointXYZRGB> (refinedCylinder2, "sample cloud2");
    viewer3->addCoordinateSystem (1.0);
    viewer3->initCameraParameters ();
    viewer3->addPlane(*PlaneCoefficients, "planeX");
    viewer3->addCylinder(*coefficients_cylinder1, "cylinderX");

    while (!viewer3->wasStopped ())
    {
        viewer3->spinOnce (100);
        boost::this_thread::sleep (boost::posix_time::microseconds (100000));
    }

    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer4 (new pcl::visualization::PCLVisualizer ("3D Viewer3"));
    viewer4->setBackgroundColor (0, 0, 0);
    viewer4->addPointCloud<pcl::PointXYZRGB> (refinedPlane, "sample cloud2");
    viewer4->addCoordinateSystem (1.0);
    viewer4->initCameraParameters ();
    viewer4->addPlane(*PlaneCoefficients2, "planeX");
    viewer4->addCylinder(*coefficients_cylinder1, "cylinderX");

    while (!viewer4->wasStopped ())
    {
        viewer4->spinOnce (100);
        boost::this_thread::sleep (boost::posix_time::microseconds (100000));
    }

    boost::shared_ptr<pcl::visualization::PCLVisualizer> viewer5 (new pcl::visualization::PCLVisualizer ("3D Viewer4"));
    viewer5->setBackgroundColor (0, 0, 0);
    viewer5->addPointCloud<pcl::PointXYZRGB> (refinedCylinder3, "sample cloud2");
    viewer5->addCoordinateSystem (1.0);
    viewer5->initCameraParameters ();
//    viewer5->addPlane(*PlaneCoefficients2, "planeX");
    viewer5->addCylinder(*coefficients_cylinder2, "cylinderX");

    while (!viewer5->wasStopped ())
    {
        viewer5->spinOnce (100);
        boost::this_thread::sleep (boost::posix_time::microseconds (100000));
    }
*/
}

